I’m rebuilding a PySide6 desktop app called “LunaQt2”. The new UI layer is already structured with:

- `src/ui/` (sidebar widgets), `src/widgets/` (buttons, cell gutters, menubar, status bar), `src/theme/` + `style_loader.py` (QSS pipeline), plus shared helpers in `src/constants/` and `src/utils/`.
- Entry point `main.py` wires up the main window, sidebars, theme toggles, and a styling pipeline that loads bundled fonts and applies a generated QSS stylesheet (`qss_runtime_dump.txt` mirrors the applied style).

The old app (kept in `OLD_LUNA_QT/lunaqt/src/`) mixed UI and logic but its “core” layer worked well. Its tree included `core/` (notebook/cell managers, data store, execution helpers) and `gui/` (Qt widgets). I want to bring that proven core logic forward while keeping the new UI cleanly separated.

Design principles (from `LunaQt_Best_Practices.md`):
- Files/folders use `snake_case`; classes `PascalCase`; functions/vars `snake_case`.
- One responsibility per module, type hints everywhere, mypy, black, ruff.
- Qt-specific code should stay isolated so the domain/core logic stays testable without Qt.

Ask: Propose a modern folder/package structure for LunaQt2 that keeps the PySide6 UI code and styling pipeline isolated from the application core (notebook & cell data models, persistence, execution pipeline). Suggest the top-level packages, what belongs in each (e.g., controllers/adapters vs pure domain services), and how to organize shared constants/utilities. Feel free to draw inspiration from the old `core/` layout but improve it so future features like notebook persistence, cell execution, and settings sync slot into the non-UI layer cleanly.

Please explain your reasoning and note any trade-offs or optional variations.